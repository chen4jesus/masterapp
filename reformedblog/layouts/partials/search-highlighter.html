<style>
  mark.search-highlight {
    background-color: #ffeb3b;
    color: #000;
    padding: 0 2px;
    border-radius: 2px;
    font-weight: 600;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
  }
  mark.search-highlight.active {
    background-color: #f57c00;
    color: #fff;
    box-shadow: 0 0 8px rgba(245, 124, 0, 0.6);
    transform: scale(1.1);
  }
  .dark mark.search-highlight {
    background-color: #fdd835;
    color: #000;
  }
  .dark mark.search-highlight.active {
    background-color: #fb8c00;
    color: #000;
  }

  #search-nav-bar {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%) translateY(100px);
    z-index: 100;
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(15, 23, 42, 0.9);
    backdrop-filter: blur(12px);
    padding: 6px 12px;
    border-radius: 99px;
    border: 1px solid rgba(255, 255, 255, 0.15);
    box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.4);
    transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
    color: white;
    opacity: 0;
  }
  #search-nav-bar.show {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
  }

  #in-page-search-input {
    background: transparent;
    border: none;
    color: white;
    font-size: 14px;
    padding: 4px 8px;
    width: 140px;
    outline: none;
    border-right: 1px solid rgba(255, 255, 255, 0.2);
    margin-right: 4px;
  }
  #in-page-search-input::placeholder {
    color: rgba(255, 255, 255, 0.4);
  }

  .search-nav-btn {
    background: rgba(255, 255, 255, 0.1);
    border: none;
    color: white;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
  }
  .search-nav-btn:hover:not(:disabled) {
    background: rgba(255, 255, 255, 0.2);
  }
  .search-nav-btn:disabled {
    opacity: 0.2;
    cursor: default;
  }

  .search-nav-count {
    font-size: 13px;
    font-weight: 600;
    min-width: 50px;
    text-align: center;
    opacity: 0.9;
  }
</style>

<div id="search-nav-bar">
  <input type="text" id="in-page-search-input" placeholder="Find in page..." autocomplete="off">
  <button id="search-prev" class="search-nav-btn" title="Previous (Shift+Enter)">
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M15 18l-6-6 6-6"/></svg>
  </button>
  <span class="search-nav-count" id="search-nav-count">0/0</span>
  <button id="search-next" class="search-nav-btn" title="Next (Enter)">
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M9 18l6-6-6-6"/></svg>
  </button>
  <button id="search-close-nav" class="search-nav-btn" style="margin-left: 4px; opacity: 0.6;" title="Close (Esc)">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M18 6L6 18M6 6l12 12"/></svg>
  </button>
</div>

<script>
document.addEventListener("DOMContentLoaded", function() {
  const contentArea = document.querySelector('.content') || document.querySelector('article') || document.body;
  const navBar = document.getElementById('search-nav-bar');
  const searchInput = document.getElementById('in-page-search-input');
  const countDisplay = document.getElementById('search-nav-count');
  const prevBtn = document.getElementById('search-prev');
  const nextBtn = document.getElementById('search-next');
  const closeBtn = document.getElementById('search-close-nav');
  const triggerBtn = document.getElementById('in-page-search-trigger');

  let marks = [];
  let currentIndex = -1;
  let originalContent = contentArea.innerHTML;

  function clearHighlights() {
    // Faster way to clear: replace child nodes if they are marks
    const highlighted = contentArea.querySelectorAll('mark.search-highlight');
    highlighted.forEach(mark => {
      const parent = mark.parentNode;
      parent.replaceChild(document.createTextNode(mark.textContent), mark);
      parent.normalize(); // Merge adjacent text nodes
    });
    marks = [];
    currentIndex = -1;
    updateUI();
  }

  function highlightText(term) {
    clearHighlights();
    if (!term || term.length < 1) return;

    const walker = document.createTreeWalker(contentArea, NodeFilter.SHOW_TEXT, null, false);
    const nodes = [];
    let currentNode;
    while (currentNode = walker.nextNode()) {
      if (currentNode.parentElement.closest('script, style, noscript, textarea, pre, code')) continue;
      nodes.push(currentNode);
    }

    const regex = new RegExp(`(${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');

    nodes.forEach(textNode => {
      const text = textNode.nodeValue;
      if (regex.test(text)) {
        const fragment = document.createDocumentFragment();
        let lastIndex = 0;
        text.replace(regex, (match, p1, offset) => {
          fragment.appendChild(document.createTextNode(text.substring(lastIndex, offset)));
          const mark = document.createElement('mark');
          mark.className = 'search-highlight';
          mark.textContent = match;
          fragment.appendChild(mark);
          lastIndex = offset + match.length;
        });
        fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
        textNode.parentNode.replaceChild(fragment, textNode);
      }
    });

    marks = Array.from(contentArea.querySelectorAll('mark.search-highlight'));
    if (marks.length > 0) {
      // Find the first mark that is below the current scroll position, or just the first mark ever
      // The user asked for "very first result initially", which usually means the top-most one.
      scrollToMark(0);
    }
    updateUI();
  }

  function scrollToMark(index) {
    if (index < 0 || index >= marks.length) return;
    marks.forEach(m => m.classList.remove('active'));
    const mark = marks[index];
    mark.classList.add('active');

    const headerHeight = document.querySelector('header')?.offsetHeight || 60;
    const rect = mark.getBoundingClientRect();
    window.scrollTo({
      top: rect.top + window.scrollY - headerHeight - 100,
      behavior: 'smooth'
    });
    currentIndex = index;
    updateUI();
  }

  function updateUI() {
    countDisplay.textContent = marks.length > 0 ? `${currentIndex + 1}/${marks.length}` : '0/0';
    prevBtn.disabled = marks.length === 0;
    nextBtn.disabled = marks.length === 0;
  }

  // Event Listeners
  searchInput.addEventListener('input', (e) => {
    highlightText(e.target.value.trim());
  });

  searchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      if (e.shiftKey) prevBtn.click();
      else nextBtn.click();
    }
  });

  nextBtn.onclick = () => {
    if (marks.length === 0) return;
    scrollToMark((currentIndex + 1) % marks.length);
  };

  prevBtn.onclick = () => {
    if (marks.length === 0) return;
    scrollToMark((currentIndex - 1 + marks.length) % marks.length);
  };

  closeBtn.onclick = () => {
    navBar.classList.remove('show');
    clearHighlights();
    searchInput.value = '';
  };

  if (triggerBtn) {
    triggerBtn.onclick = () => {
      navBar.classList.add('show');
      setTimeout(() => searchInput.focus(), 100);
    };
  }

  // Handle URL param on load
  const urlParams = new URLSearchParams(window.location.search);
  const highlightTerm = urlParams.get('highlight');
  if (highlightTerm) {
    navBar.classList.add('show');
    searchInput.value = highlightTerm;
    highlightText(highlightTerm);
    // Cleanup URL
    const cleanUrl = window.location.protocol + "//" + window.location.host + window.location.pathname;
    window.history.replaceState({path: cleanUrl}, '', cleanUrl);
  }

  // Keyboard Shortcuts
  document.addEventListener('keydown', (e) => {
    // Alt+K for Find
    if (e.altKey && e.key.toLowerCase() === 'k') {
      e.preventDefault();
      triggerBtn.click();
    }
    if (navBar.classList.contains('show')) {
      if (e.key === 'Escape') closeBtn.click();
      if (e.key === 'n' && document.activeElement !== searchInput) nextBtn.click();
      if (e.key === 'p' && document.activeElement !== searchInput) prevBtn.click();
    }
  });
});
</script>
